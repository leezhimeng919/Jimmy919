<!-- MarkdownTOC -->

- [作用域和闭包](#作用域和闭包)
    - [作用域是什么](#作用域是什么)
        - [编译原理](#编译原理)
        - [理解作用域](#理解作用域)
        - [作用域嵌套](#作用域嵌套)
        - [异常](#异常)
    - [词法作用域](#词法作用域)
        - [词法阶段](#词法阶段)
        - [欺骗词法](#欺骗词法)
        - [性能](#性能)
    - [函数作用域和块作用域](#函数作用域和块作用域)
        - [函数中的作用域](#函数中的作用域)
        - [隐藏内部实现](#隐藏内部实现)
        - [函数作用域](#函数作用域)
        - [块作用域](#块作用域)
    - [提升](#提升)
        - [变量声明提升和函数声明提升](#变量声明提升和函数声明提升)
        - [编译器处理提升](#编译器处理提升)
        - [函数优先](#函数优先)
    - [作用域闭包](#作用域闭包)
        - [实质问题](#实质问题)
        - [循环和闭包](#循环和闭包)
        - [模块](#模块)
    - [附录](#附录)
        - [动态作用域](#动态作用域)
        - [块级作用域的替代方案](#块级作用域的替代方案)
        - [this词法](#this词法)
- [this和对象原型](#this和对象原型)
    - [关于this](#关于this)
        - [为什么要用this](#为什么要用this)
        - [误解](#误解)
        - [this到底是什么](#this到底是什么)
    - [this全面解析](#this全面解析)
        - [调用位置](#调用位置)
        - [绑定规则](#绑定规则)
        - [优先级](#优先级)
        - [绑定例外](#绑定例外)
        - [this词法](#this词法-1)
    - [对象](#对象)
    - [混合对象“类”](#混合对象“类”)
    - [原型](#原型)
    - [行为委托](#行为委托)
    - [ES6中的class](#es6中的class)

<!-- /MarkdownTOC -->


<a id="作用域和闭包"></a>
# 作用域和闭包
<a id="作用域是什么"></a>
## 作用域是什么 
- 作用域是一套设计良好的规则。用来存储变量，并且之后可以方便的找到这些变量。

<a id="编译原理"></a>
### 编译原理
- 传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤
    + 分词/词法分析(tokenizing/lexing)
        * 词法化(单词化)这个过程会将字符组成的代码分解成有意义的代码块(词法单元)
        * `var a = 1;`被分解成var、a、=、1、;。空格在关键的地方会被当做词法单元
        * 词法分析是*有状态*的解析规则进行的(即`ab`分成`a`和`b`还是`ab`要判断语境)
    + 解析/语法分析(Parsing)
        * 这个过程将词法单元流(数组)转换成一个代表了程序语法结构的由元素逐级嵌套所组成的的树(抽象语法树,AST)。
        * `var a = 1;`转换成的抽象语法树有一个叫VariableDeclaration(变量声明)的顶级节点，接下来是一个值为a叫做Identifier(标识符)的子节点，以及一个值为=叫做AssignmentExpression(赋值表达式)的子节点。AssignmentExpression有一个值为1叫做NumericLiteral(数字文字)的子节点
    + 代码生成
        * 这个过程将AST转换为可执行代码。这个过程和语言、目标平台息息相关
        * 将`var a = 1;`的AST转化为一组机器指令，用来创建一个叫做a的变量(包括分配内存等)，并将一个值存储在a中
- JavaScript代码片段不是提前编译的，它 **就在** 执行前进行编译，编译发生在代码执行前几微秒甚至更短。编译结果不能在分布式系统中进行移植
    + JavaScript编译器会对`var a = 1;`进行编译，然后做好执行它的准备，并通常马上执行

<a id="理解作用域"></a>
### 理解作用域
- 引擎
    + 职责：从头到尾负责整个JavaScript程序的编译及执行过程
    + 术语：LHS和RHS
        + 在使用变量时，引擎会通过这两种查找来判断变量是否被声明
        + 分别表示赋值操作的左侧和右侧
        + LHS：目的是对变量进行赋值，对哪个变量赋值就对哪个变量进行LHS引用。对变量显式的赋值或者调用函数时传入实参就是LHS引用,如a = 1
        + RHS：目的是获取变量的值，获取哪个变量的值就是对哪个变量进行RHS引用。通过引用变量来获取值就是RHS引用，如console.log(a)
       
- 编译器
    + 职责：引擎的好朋友，负责词法分析、语法分析及代码生成等脏活累活
    + 变量的赋值操作：会执行两个动作
        + 首先编译器会在当前作用域中声明一个变量(如果之前没声明过)。这会在最开始的阶段，代码执行前进行。
        + 然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值
- 作用域
    + 职责：引擎的另一位好朋友，负责收集并维护所有变量(声明的标识符)组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

<a id="作用域嵌套"></a>
### 作用域嵌套
- 在当前作用域种无法找到某个变量，引擎就会在外层嵌套的作用域种继续查找，直到找到该变量为止。
- 作用域链

<a id="异常"></a>
### 异常
- 为什么要区分LHS和RHS
    + 因为在变量没有被声明的情况下这两种查询的行为是不一样的
    + 用RHS引用查看变量是否被声明时，如果没声明(整条作用域链中)则抛出异常ReferenceError(引用异常，同作用域判别失败相关)
    + 用LHS引用查看变量是否被声明时，非严格模式下不会抛出异常，而且全局作用域中会创建该变量，并将其返还给引擎。严格模式下会抛出跟RHS一样的异常
    + 若RHS找到了变量，但尝试对这个变量做不合理的操作，如null.getName()会抛出异常TypeError(类型异常，作用域判别成功，对判别结果的操作异常)

<a id="词法作用域"></a>
## 词法作用域
- 作用域共有两种主要的工作模型
    + 词法作用域
    + 动态作用域

<a id="词法阶段"></a>
### 词法阶段
- 词法作用域就是定义在词法阶段的作用域。
- 词法作用域是由你在写代码时将变量和块作用域写在哪来决定的，因此当词法分析器处理代码时会保持作用域不变(除非使用欺骗词法作用域的方法)
- 查找：作用域会在找到第一个匹配的标识符停止
- 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。

<a id="欺骗词法"></a>
### 欺骗词法
- 欺骗词法作用域会导致性能下降
- `eval`和`with`能实现欺骗词法的目的
    + `eval()`接受一个字符串作为参数，并将其内容视为好像在书写代就存在于这个位置的代码。eval中的声明可以在运行期修改书写期的词法作用域
        + 严格模式下，eval中的声明无法修改所在的作用域
        + `setInterval`和`setTimeout`的第一个参数也可以是字符串类似于eval。不提倡
        + `new Function`的最后一个参数也可以接受字符串，避免使用
    - `with` 通常被当做重复引用同一个对象的多个属性的快捷方式，可以不需要重复引用对象本身
        + with可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域
        + 尽管with块可以将一个对象处理为词法作用域，但是这个块内部正常的var声明并不会被限制在这个块的作用域，而是被添加到with所处的作用域中
- eval函数如果接受了含有一个或多个声明的代码的字符串，就会[修改]其所处的词法作用域
- with声明实际上是根据你传递给它的对象凭空 [创建了一个全新] 的词法作用域
- 一个不推荐使用eval和with的原因是会被严格模式所影响

<a id="性能"></a>
### 性能
- 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符

<a id="函数作用域和块作用域"></a>
## 函数作用域和块作用域
<a id="函数中的作用域"></a>
### 函数中的作用域
- 属于这个函数的全部变量都可以在整个函数的范围内使用及复用

<a id="隐藏内部实现"></a>
### 隐藏内部实现
- 规避冲突
    + 全局命名空间
    + 模块管理

<a id="函数作用域"></a>
### 函数作用域
- 匿名和具名
- 立即执行函数表达式

<a id="块作用域"></a>
### 块作用域
- with
- try/catch
    + catch语句
- let
- const

<a id="提升"></a>
## 提升
<a id="变量声明提升和函数声明提升"></a>
### 变量声明提升和函数声明提升
- 提升：变量和函数声明从它们在代码中出现的位置被移动到作用域最顶端的过程
- 只有声明本身会被提升，而赋值或其他运行逻辑会留在原地

<a id="编译器处理提升"></a>
### 编译器处理提升
- 包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理
- 函数表达式不会提升，若在函数表达式初始化函数之前调用函数会报TypeError
```
foo();//TypeError，此时foo不是函数，是undefined
bar();//ReferenceError
var foo = function bar (){
    ...
}
```

<a id="函数优先"></a>
### 函数优先
- 函数声明提升优先于变量声明提升

<a id="作用域闭包"></a>
## 作用域闭包
- 当函数可以记住并访问所在的词法作用域时，即使函数是在当前词法作用域之外执行。就产生的闭包

<a id="实质问题"></a>
### 实质问题
- 闭包定义：当函数在其本身的词法作用域以外执行时，闭包就产生了
- 词法作用域的查找规则只是闭包的一部分，也是非常重要的一部分
- 几个关于闭包的说法：
    + 闭包是一个函数
    + 闭包一个作用域的容器
    + 闭包是一个引用，内部函数对外部作用域的引用
    + 闭包是一个标准，关于如何在函数作为值按需传递的词法环境中书写代码的标准
    + 总结：闭包让函数在别处被调用时可以继续访问定义时的词法作用域
- 内部函数具有一个涵盖包含函数作用域的闭包
- 无论通过何种手段将内部函数传递到所在的此法作用于以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包
- 自执行函数没用闭包，但同闭包息息相关
    + 息息相关：IIFE是最常用来创建被封闭起来的闭包的工具
    + 没用到闭包：函数并不是在其本身的词法作用域以外执行
- 只要用了回调函数就在使用闭包

<a id="循环和闭包"></a>
### 循环和闭包
```
for(var i = 1; i <= 5; i ++){
    setTimeout(function(){
            console.log(i)
        },i * 1000);
}
//每秒一次共输出5个6
```
- 原因：i是全局作用域中声明，延迟函数的回调会在循环结束时执行。循环结束时i=6
- 解决方案：
    + IIFE内部换一个迭代参数
    + let i=1

<a id="模块"></a>
### 模块
- 模块机制
    + 模块是利用闭包的代码模式中最强大的一个
    + 最常见的实现模块模式的方法通常被称为 **模块暴露**
    + 模块模式的两个必要条件
        * 必须有外部的封闭函数(引入包装函数)，该函数必须至少被调用一次，每次调用都会创建一个新的模块实例
        * 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态
    + 一个从函数调用所返回的只有数据属性而没有闭包函数的对象并不是真正的模块
        * 说明：函数调用的返回值中没有闭包函数的对象不是模块
- 现代的模块机制
    + 基于函数的模块
    + 大多数模块依赖加载器/管理器。本质上都是将这种模块定义封装进一个友好的API
```
//封装进一个友好的API
var myModules = (function(){
    var modules = {};
    
    var get = function(name){
        return modules[name]
    }
  
    
    var define = function(name,deps,impl){
        
        for(var i=0; i<deps.length; i++){
            deps[i] = modules[deps[i]]
        }
        modules[name] = impl.apply(impl,deps)
    }


    return {
        get:get,
        define:define
    }
      })()

//使用友好的API定义模块
myModules.define("bar",[],function(){
    function hello(who){
        return "hello" + who;
    }
    return {
        hello:hello
    }
    })

myModules.define("foo",["bar"],function(bar){
    var hungry = "hippo";
    function awesome(){
        console.log(bar.hello(hungry).toUpperCase());
    }

    return {
        awesome: awesome
    }
    });

var bar = myModules.get("bar");
var foo = myModules.get("foo");

console.log(bar.hello("hippo"))
foo.awesome()
```

- 未来的模块机制
    + ES6中为模块增加了一级语法支持
        通过模块系统进行加载时，ES6会将文件当做独立的模块来处理。每个模块都可以导入其他模块或特定的API成员，同样也可以导出自己的API成员
    + ES6模块相比基于函数的模块更加稳定
        * 基于函数的模块无法被编译器识别，API语义只有在运行时才会被考虑。因此可以在运行时修改一个模块的API
        * ES6模块的API不会在运行时改变，编译器会在编译期间对导入模块API成员的引用检查是否真实存在，若不存在会在运行时更早的抛错
    + ES6模块必须被定义在独立的文件中，即一个文件一个模块。浏览器或引擎可以在导入模块时异步的加载模块文件
```
bar.js
    function hello(who){
        return "hello" + who;

    }
    export hello;

foo.js
    //导入bar模块中的hello函数
    import hello from "bar"
    var hungry = "hippo";
    function awesome(){
        console.log(hello(hungry).toUpperCase())
    }

    export awesome;

baz.js
    //导入完整的模块
    module foo form "foo";
    module bar form "bar";

    console.log(bar.hello("lzm"))
    bar.awesome()
```
    + import 将一个模块中的一个或多个API导入到当前作用于中，并分别绑定在一个变量上
    + module 将整个模块的API导入并绑定到一个变量上
    + export 将当前模块的一个标识符导出为公共API

<a id="附录"></a>
## 附录
<a id="动态作用域"></a>
### 动态作用域
- JavaScript不具有动态作用域
- 动态作用域与this机制
- 动态作用域的作用域链是基于调用栈的，而不是代码中的作用域嵌套
- 区别
    + 词法作用域是在定义时确定的，关注函数在何处声明
    + 动态作用域是在运行时确定改的，关注函数从何调用

<a id="块级作用域的替代方案"></a>
### 块级作用域的替代方案
```
{
    let a = 2;
    console.log(a)//2
}
console.log(a)//ReferenceError
```
- ES6之前实现：ES3 catch
```
try{
    throw 2
}catch(a){
    console.log(a)//2
}
console.log(a)//ReferenceError
```
- Traceur
    + google维护的项目，该项目将ES6代码转换成兼容ES6之前的环境
```
//Traceur将ES6块作用域的代码片段转换成下列代码
{
    try {
        throw undefined
    } catch(a){
        a = 2
        console.log(a)
    }
}
console.log(a)
```
- 隐式和显式作用域
    + let关键字隐式的创建块作用域
    + let声明会创建一个显式的作用域并进行绑定(需要使用工具let-er)
```
//let 声明,使用let-er工具
let(a=2){
    console.log(a)
}
```
- 性能
    + try/catch的性能很糟糕，但正在改进
    + IIFE不是一个普适性的方案，因为它毕竟是一个函数

<a id="this词法"></a>
### this词法
- 箭头函数
```
var foo = a =>{
    console.log(a)
}
foo(2) //2
```
- 箭头函数引入了叫this词法的行为
    + 箭头函数涉及this绑定的行为和普通函数this绑定的行为不一致
    + 箭头函数用当前的词法作用域覆盖了this的本来的值，而不是运行时作用域
- 箭头函数不理想
    + 混淆使用两种this
    + 匿名函数不理想
- 用bind代替箭头函数
- 箭头函数不仅仅意味着少写代码

<a id="this和对象原型"></a>
# this和对象原型
<a id="关于this"></a>
## 关于this
<a id="为什么要用this"></a>
### 为什么要用this
- this提供一种更优雅的方式来隐式传递一个对象引用，使得代码更加简洁和易于复用

<a id="误解"></a>
### 误解
- this指向自身
- this指向函数作用域
    + this在任何情况下都不指向函数的词法作用域

<a id="this到底是什么"></a>
### this到底是什么
- this的绑定和函数声明的位置没有关系，只取决于函数的调用方式
- this是函数调用时活动对象的一个属性，arguments和函数参数也是活动对象的属性

<a id="this全面解析"></a>
## this全面解析
<a id="调用位置"></a>
### 调用位置
- 调用位置：函数被调用的位置。调用位置就在当前执行函数的前一个调用中。
- 调用栈：存放了为了到达当前执行位置所调用的所有函数。

<a id="绑定规则"></a>
### 绑定规则
- 默认绑定
    + 独立函数调用，指向全局
- 隐式绑定
    + 函数作为对象的方法，指向对象
    + 隐式丢失
        * 把对象方法赋值给另一个变量。`var foo = obj.bar`
        * 将对象方法作为参数传入回调函数，传递参数是一种隐式赋值。`doBar(obj.bar)`
- 显式绑定
    + call()和apply()
- new绑定

<a id="优先级"></a>
### 优先级
<a id="绑定例外"></a>
### 绑定例外
<a id="this词法-1"></a>
### this词法
<a id="对象"></a>
## 对象
<a id="混合对象“类”"></a>
## 混合对象“类”
<a id="原型"></a>
## 原型
<a id="行为委托"></a>
## 行为委托
<a id="es6中的class"></a>
## ES6中的class







