<!-- MarkdownTOC -->

- [作用域和闭包](#作用域和闭包)
    - [作用域是什么](#作用域是什么)
        - [编译原理](#编译原理)
        - [理解作用域](#理解作用域)
        - [作用域嵌套](#作用域嵌套)
        - [异常](#异常)
    - [词法作用域](#词法作用域)
        - [词法阶段](#词法阶段)
        - [欺骗词法](#欺骗词法)
        - [性能](#性能)
    - [函数作用域和块作用域](#函数作用域和块作用域)
        - [函数中的作用域](#函数中的作用域)
        - [隐藏内部实现](#隐藏内部实现)
        - [函数作用域](#函数作用域)
        - [块作用域](#块作用域)
    - [提升](#提升)
        - [变量声明提升和函数声明提升](#变量声明提升和函数声明提升)
        - [编译器处理提升](#编译器处理提升)
        - [函数优先](#函数优先)
    - [作用域闭包](#作用域闭包)
        - [实质问题](#实质问题)
        - [循环和闭包](#循环和闭包)
        - [模块](#模块)
    - [附录](#附录)
        - [动态作用域](#动态作用域)
        - [块级作用域的替代方案](#块级作用域的替代方案)
        - [this词法](#this词法)
- [this和对象原型](#this和对象原型)
    - [关于this](#关于this)
        - [为什么要用this](#为什么要用this)
        - [误解](#误解)
        - [this到底是什么](#this到底是什么)
    - [this全面解析](#this全面解析)
        - [调用位置](#调用位置)
        - [绑定规则](#绑定规则)
        - [优先级](#优先级)
        - [绑定例外](#绑定例外)
        - [重提this词法](#重提this词法)
    - [对象](#对象)
        - [对象语法](#对象语法)
        - [对象类型](#对象类型)
        - [对象的内容](#对象的内容)
        - [遍历](#遍历)
    - [混合对象“类”](#混合对象“类”)
        - [类理论](#类理论)
        - [类的机制](#类的机制)
        - [类的继承](#类的继承)
        - [混入](#混入)
    - [原型](#原型)
    - [行为委托](#行为委托)
    - [ES6中的class](#es6中的class)
- [类型和语法](#类型和语法)
    - [类型](#类型)
    - [值](#值)
    - [原生函数](#原生函数)
    - [强制类型转换](#强制类型转换)
    - [语法](#语法)
    - [混合环境JavaScript](#混合环境javascript)
- [异步和性能](#异步和性能)
    - [异步的现在和将来](#异步的现在和将来)
    - [回调](#回调)
    - [Promise](#promise)
    - [生成器](#生成器)
    - [程序性能](#程序性能)
    - [性能测试与调优](#性能测试与调优)
    - [asynquence库](#asynquence库)
    - [高级异步模式](#高级异步模式)
- [起步上路](#起步上路)
    - [深入编程](#深入编程)
    - [深入JavaScript](#深入javascript)
- [ES6及更新版本](#es6及更新版本)
    - [ES的现在与未来](#es的现在与未来)
    - [ES6语法](#es6语法)
    - [代码组织](#代码组织)
    - [异步流控制](#异步流控制)
    - [集合](#集合)
    - [新增API](#新增api)
    - [元编程](#元编程)
    - [ES6之后](#es6之后)

<!-- /MarkdownTOC -->


<a id="作用域和闭包"></a>
# 作用域和闭包
<a id="作用域是什么"></a>
## 作用域是什么 
- 作用域是一套设计良好的规则。用来存储变量，并且之后可以方便的找到这些变量。

<a id="编译原理"></a>
### 编译原理
- 传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤
    + 分词/词法分析(tokenizing/lexing)
        * 词法化(单词化)这个过程会将字符组成的代码分解成有意义的代码块(词法单元)
        * `var a = 1;`被分解成var、a、=、1、;。空格在关键的地方会被当做词法单元
        * 词法分析是*有状态*的解析规则进行的(即`ab`分成`a`和`b`还是`ab`要判断语境)
    + 解析/语法分析(Parsing)
        * 这个过程将词法单元流(数组)转换成一个代表了程序语法结构的由元素逐级嵌套所组成的的树(抽象语法树,AST)。
        * `var a = 1;`转换成的抽象语法树有一个叫VariableDeclaration(变量声明)的顶级节点，接下来是一个值为a叫做Identifier(标识符)的子节点，以及一个值为=叫做AssignmentExpression(赋值表达式)的子节点。AssignmentExpression有一个值为1叫做NumericLiteral(数字文字)的子节点
    + 代码生成
        * 这个过程将AST转换为可执行代码。这个过程和语言、目标平台息息相关
        * 将`var a = 1;`的AST转化为一组机器指令，用来创建一个叫做a的变量(包括分配内存等)，并将一个值存储在a中
- JavaScript代码片段不是提前编译的，它 **就在** 执行前进行编译，编译发生在代码执行前几微秒甚至更短。编译结果不能在分布式系统中进行移植
    + JavaScript编译器会对`var a = 1;`进行编译，然后做好执行它的准备，并通常马上执行

<a id="理解作用域"></a>
### 理解作用域
- 引擎
    + 职责：从头到尾负责整个JavaScript程序的编译及执行过程
    + 术语：LHS和RHS
        + 在使用变量时，引擎会通过这两种查找来判断变量是否被声明
        + 分别表示赋值操作的左侧和右侧
        + LHS：目的是对变量进行赋值，对哪个变量赋值就对哪个变量进行LHS引用。对变量显式的赋值或者调用函数时传入实参就是LHS引用,如a = 1
        + RHS：目的是获取变量的值，获取哪个变量的值就是对哪个变量进行RHS引用。通过引用变量来获取值就是RHS引用，如console.log(a)
       
- 编译器
    + 职责：引擎的好朋友，负责词法分析、语法分析及代码生成等脏活累活
    + 变量的赋值操作：会执行两个动作
        + 首先编译器会在当前作用域中声明一个变量(如果之前没声明过)。这会在最开始的阶段，代码执行前进行。
        + 然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值
- 作用域
    + 职责：引擎的另一位好朋友，负责收集并维护所有变量(声明的标识符)组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

<a id="作用域嵌套"></a>
### 作用域嵌套
- 在当前作用域种无法找到某个变量，引擎就会在外层嵌套的作用域种继续查找，直到找到该变量为止。
- 作用域链

<a id="异常"></a>
### 异常
- 为什么要区分LHS和RHS
    + 因为在变量没有被声明的情况下这两种查询的行为是不一样的
    + 用RHS引用查看变量是否被声明时，如果没声明(整条作用域链中)则抛出异常ReferenceError(引用异常，同作用域判别失败相关)
    + 用LHS引用查看变量是否被声明时，非严格模式下不会抛出异常，而且全局作用域中会创建该变量，并将其返还给引擎。严格模式下会抛出跟RHS一样的异常
    + 若RHS找到了变量，但尝试对这个变量做不合理的操作，如null.getName()会抛出异常TypeError(类型异常，作用域判别成功，对判别结果的操作异常)

<a id="词法作用域"></a>
## 词法作用域
- 作用域共有两种主要的工作模型
    + 词法作用域
    + 动态作用域

<a id="词法阶段"></a>
### 词法阶段
- 词法作用域就是定义在词法阶段的作用域。
- 词法作用域是由你在写代码时将变量和块作用域写在哪来决定的，因此当词法分析器处理代码时会保持作用域不变(除非使用欺骗词法作用域的方法)
- 查找：作用域会在找到第一个匹配的标识符停止
- 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。

<a id="欺骗词法"></a>
### 欺骗词法
- 欺骗词法作用域会导致性能下降
- `eval`和`with`能实现欺骗词法的目的
    + `eval()`接受一个字符串作为参数，并将其内容视为好像在书写代就存在于这个位置的代码。eval中的声明可以在运行期修改书写期的词法作用域
        + 严格模式下，eval中的声明无法修改所在的作用域
        + `setInterval`和`setTimeout`的第一个参数也可以是字符串类似于eval。不提倡
        + `new Function`的最后一个参数也可以接受字符串，避免使用
    - `with` 通常被当做重复引用同一个对象的多个属性的快捷方式，可以不需要重复引用对象本身
        + with可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域
        + 尽管with块可以将一个对象处理为词法作用域，但是这个块内部正常的var声明并不会被限制在这个块的作用域，而是被添加到with所处的作用域中
- eval函数如果接受了含有一个或多个声明的代码的字符串，就会[修改]其所处的词法作用域
- with声明实际上是根据你传递给它的对象凭空 [创建了一个全新] 的词法作用域
- 一个不推荐使用eval和with的原因是会被严格模式所影响

<a id="性能"></a>
### 性能
- 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符

<a id="函数作用域和块作用域"></a>
## 函数作用域和块作用域
<a id="函数中的作用域"></a>
### 函数中的作用域
- 属于这个函数的全部变量都可以在整个函数的范围内使用及复用

<a id="隐藏内部实现"></a>
### 隐藏内部实现
- 规避冲突
    + 全局命名空间
    + 模块管理

<a id="函数作用域"></a>
### 函数作用域
- 匿名和具名
- 立即执行函数表达式

<a id="块作用域"></a>
### 块作用域
- with
- try/catch
    + catch语句
- let
- const

<a id="提升"></a>
## 提升
<a id="变量声明提升和函数声明提升"></a>
### 变量声明提升和函数声明提升
- 提升：变量和函数声明从它们在代码中出现的位置被移动到作用域最顶端的过程
- 只有声明本身会被提升，而赋值或其他运行逻辑会留在原地

<a id="编译器处理提升"></a>
### 编译器处理提升
- 包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理
- 函数表达式不会提升，若在函数表达式初始化函数之前调用函数会报TypeError
```
foo();//TypeError，此时foo不是函数，是undefined
bar();//ReferenceError
var foo = function bar (){
    ...
}
```

<a id="函数优先"></a>
### 函数优先
- 函数声明提升优先于变量声明提升

<a id="作用域闭包"></a>
## 作用域闭包
- 当函数可以记住并访问所在的词法作用域时，即使函数是在当前词法作用域之外执行。就产生的闭包

<a id="实质问题"></a>
### 实质问题
- 闭包定义：当函数在其本身的词法作用域以外执行时，闭包就产生了
- 词法作用域的查找规则只是闭包的一部分，也是非常重要的一部分
- 几个关于闭包的说法：
    + 闭包是一个函数
    + 闭包一个作用域的容器
    + 闭包是一个引用，内部函数对外部作用域的引用
    + 闭包是一个标准，关于如何在函数作为值按需传递的词法环境中书写代码的标准
    + 总结：闭包让函数在别处被调用时可以继续访问定义时的词法作用域
- 内部函数具有一个涵盖包含函数作用域的闭包
- 无论通过何种手段将内部函数传递到所在的此法作用于以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包
- 自执行函数没用闭包，但同闭包息息相关
    + 息息相关：IIFE是最常用来创建被封闭起来的闭包的工具
    + 没用到闭包：函数并不是在其本身的词法作用域以外执行
- 只要用了回调函数就在使用闭包

<a id="循环和闭包"></a>
### 循环和闭包
```
for(var i = 1; i <= 5; i ++){
    setTimeout(function(){
            console.log(i)
        },i * 1000);
}
//每秒一次共输出5个6
```
- 原因：i是全局作用域中声明，延迟函数的回调会在循环结束时执行。循环结束时i=6
- 解决方案：
    + IIFE内部换一个迭代参数
    + let i=1

<a id="模块"></a>
### 模块
- 模块机制
    + 模块是利用闭包的代码模式中最强大的一个
    + 最常见的实现模块模式的方法通常被称为 **模块暴露**
    + 模块模式的两个必要条件
        * 必须有外部的封闭函数(引入包装函数)，该函数必须至少被调用一次，每次调用都会创建一个新的模块实例
        * 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态
    + 一个从函数调用所返回的只有数据属性而没有闭包函数的对象并不是真正的模块
        * 说明：函数调用的返回值中没有闭包函数的对象不是模块
- 现代的模块机制
    + 基于函数的模块
    + 大多数模块依赖加载器/管理器。本质上都是将这种模块定义封装进一个友好的API
```
//封装进一个友好的API
var myModules = (function(){
    var modules = {};
    
    var get = function(name){
        return modules[name]
    }
  
    
    var define = function(name,deps,impl){
        
        for(var i=0; i<deps.length; i++){
            deps[i] = modules[deps[i]]
        }
        modules[name] = impl.apply(impl,deps)
    }


    return {
        get:get,
        define:define
    }
      })()

//使用友好的API定义模块
myModules.define("bar",[],function(){
    function hello(who){
        return "hello" + who;
    }
    return {
        hello:hello
    }
    })

myModules.define("foo",["bar"],function(bar){
    var hungry = "hippo";
    function awesome(){
        console.log(bar.hello(hungry).toUpperCase());
    }

    return {
        awesome: awesome
    }
    });

var bar = myModules.get("bar");
var foo = myModules.get("foo");

console.log(bar.hello("hippo"))
foo.awesome()
```

- 未来的模块机制
    + ES6中为模块增加了一级语法支持
        通过模块系统进行加载时，ES6会将文件当做独立的模块来处理。每个模块都可以导入其他模块或特定的API成员，同样也可以导出自己的API成员
    + ES6模块相比基于函数的模块更加稳定
        * 基于函数的模块无法被编译器识别，API语义只有在运行时才会被考虑。因此可以在运行时修改一个模块的API
        * ES6模块的API不会在运行时改变，编译器会在编译期间对导入模块API成员的引用检查是否真实存在，若不存在会在运行时更早的抛错
    + ES6模块必须被定义在独立的文件中，即一个文件一个模块。浏览器或引擎可以在导入模块时异步的加载模块文件
```
bar.js
    function hello(who){
        return "hello" + who;

    }
    export hello;

foo.js
    //导入bar模块中的hello函数
    import hello from "bar"
    var hungry = "hippo";
    function awesome(){
        console.log(hello(hungry).toUpperCase())
    }

    export awesome;

baz.js
    //导入完整的模块
    module foo form "foo";
    module bar form "bar";

    console.log(bar.hello("lzm"))
    bar.awesome()
```
    + import 将一个模块中的一个或多个API导入到当前作用于中，并分别绑定在一个变量上
    + module 将整个模块的API导入并绑定到一个变量上
    + export 将当前模块的一个标识符导出为公共API

<a id="附录"></a>
## 附录
<a id="动态作用域"></a>
### 动态作用域
- JavaScript不具有动态作用域
- 动态作用域与this机制
- 动态作用域的作用域链是基于调用栈的，而不是代码中的作用域嵌套
- 区别
    + 词法作用域是在定义时确定的，关注函数在何处声明
    + 动态作用域是在运行时确定改的，关注函数从何调用

<a id="块级作用域的替代方案"></a>
### 块级作用域的替代方案
```
{
    let a = 2;
    console.log(a)//2
}
console.log(a)//ReferenceError
```
- ES6之前实现：ES3 catch
```
try{
    throw 2
}catch(a){
    console.log(a)//2
}
console.log(a)//ReferenceError
```
- Traceur
    + google维护的项目，该项目将ES6代码转换成兼容ES6之前的环境
```
//Traceur将ES6块作用域的代码片段转换成下列代码
{
    try {
        throw undefined
    } catch(a){
        a = 2
        console.log(a)
    }
}
console.log(a)
```
- 隐式和显式作用域
    + let关键字隐式的创建块作用域
    + let声明会创建一个显式的作用域并进行绑定(需要使用工具let-er)
```
//let 声明,使用let-er工具
let(a=2){
    console.log(a)
}
```
- 性能
    + try/catch的性能很糟糕，但正在改进
    + IIFE不是一个普适性的方案，因为它毕竟是一个函数

<a id="this词法"></a>
### this词法
- 箭头函数
```
var foo = a =>{
    console.log(a)
}
foo(2) //2
```
- 箭头函数引入了叫this词法的行为
    + 箭头函数涉及this绑定的行为和普通函数this绑定的行为不一致
    + 箭头函数用当前的词法作用域覆盖了this的本来的值，而不是运行时作用域
    + 箭头函数继承外层函数调用的this绑定
- 箭头函数不理想
    + 混淆使用两种this
    + 匿名函数不具有可读性
- 用bind()代替箭头函数
- 箭头函数不仅仅意味着少写代码

<a id="this和对象原型"></a>
# this和对象原型
<a id="关于this"></a>
## 关于this
<a id="为什么要用this"></a>
### 为什么要用this
- this提供一种更优雅的方式来隐式传递一个对象引用，使得代码更加简洁和易于复用

<a id="误解"></a>
### 误解
- this指向自身
- this指向函数作用域
    + this在任何情况下都不指向函数的词法作用域

<a id="this到底是什么"></a>
### this到底是什么
- this的绑定和函数声明的位置没有关系，只取决于函数的调用方式
- this是函数调用时活动对象的一个属性，arguments和函数参数也是活动对象的属性

<a id="this全面解析"></a>
## this全面解析
<a id="调用位置"></a>
### 调用位置
- 调用位置：函数被调用的位置。调用位置就在当前执行函数体内的前一个调用中。
- 调用栈：存放了为了到达当前执行位置所调用的所有函数。

<a id="绑定规则"></a>
### 绑定规则
- 默认绑定
    + 独立函数调用，指向全局
    + **函数体内**(而不是调用位置)在严格模式下绑定到undefined，否则绑定到全局变量
- 隐式绑定
    + 函数作为对象的方法，指向对象
    + 隐式丢失
        * 把对象方法赋值给另一个变量。`var foo = obj.bar`
        * 将对象方法作为参数传入回调函数，传递参数是一种隐式赋值。`doBar(obj.bar)`
- 显式绑定-因为可以直接指定this的绑定对象
    + call()和apply()
    + 硬绑定
        * 创建一个包裹函数
        * 创建一个可以重复使用的辅助函数
        * ES5 Function.prototype.bind(this)
            - 返回一个硬编码的新函数它会把参数设置为this的上下文并调用原始函数
```
function bind(fn,obj){
    return function(){
        return fn.apply(obj,arguments)
    }
}
```
    + API调用的上下文
        * forEach的第二个可选参数，实际上是通过call/apply实现显式绑定
- new绑定
    + 使用new来调用函数，即发生构造函数调用
        * 创建一个全新的对象`new Object()`
        * 将构造函数的作用域赋给新对象(为了this指向新对象)
        * 执行构造函数中的代码(为这个新对象添加属性)
        * 如果函数没有return，那么new函数调用会返回这个新对象

<a id="优先级"></a>
### 优先级
- new > 显示 > 隐式 > 默认
- 判断this
    + 函数是否在new中被调用?如果是，this绑定的是新创建的对象
    + 函数是否通过call/apply/bind调用？如果是，this绑定的是指定对象
    + 函数是否在某个上下文对象中被调用？如果是，this绑定的是上下文对象
        * `obj.foo()`obj的作用域即是foo函数的上下文
        * `var bar = obj.foo()`声明bar的作用域即是foo函数的上下文
    + 如果都不是，使用默认绑定。严格模式下，绑定到undefined，否则绑定到全局变量

<a id="绑定例外"></a>
### 绑定例外
- 被忽略的this
    + 使用null、undefined作为this绑定对象传入call、apply、bind
        * 使用foo.apply(null,array)展开数组,foo函数定义展开的方式
            - ES6新增...操作符可以代替展开数组
        * 使用bind(null,arguments..)预设一些参数实现柯里化
        * 副作用：可能修改全局对象
    + 更安全的this
        * 传入一个特殊的对象DMZ(demilitarized zone非军事区)，而不是传入null
        * var DMZ = Object.create(null)
        * create比{}创建的对象更空，因为不创建prototype
- 间接引用
    + (b=a)的意思是将a赋值给b并返回b，属于LHS,若不存在b会创建b
    + 默认绑定
- 软绑定
    + 硬绑定会大大降低函数灵活性，无法再修改this
    + 实现：给默认绑定指定一个全局对象和undefined以外的值

<a id="重提this词法"></a>
### 重提this词法
- 箭头函数不适用this的四种标准规则，而是根据外层作用域来决定this
- 箭头函数最常用回调函数，比如时间处理器或者定时器
- ES6之前在外层作用域中`var that = this`保留外层作用域中的this
- 只使用词法作用域并完全抛弃错误this风格的代码
    + 错误this风格指的是使用`var that = this`或者箭头函数，
    + 完全使用this机制和bind()

<a id="对象"></a>
## 对象
<a id="对象语法"></a>
### 对象语法
- 两种定义对象形式
    + 对象字面量`var myObj = { key: value }`
    + 构造形式`var myObj = new Object()`

<a id="对象类型"></a>
### 对象类型
- 数据类型
    + string
    + number
    + boolean
    + null
        * 本身是基本类型，但type null //object
    + undefined
    + object
        * function
        * array
- 内置对象
    + String
    + Number
    + Boolean
    + Object
    + Function
    + Array
    + Regex
    + Error
    + Date

<a id="对象的内容"></a>
### 对象的内容
- 属性：对象的内容是由一些存储在特定命名位置的值组成的，称之为属性
    + 访问值两种方法
        * `.`属性访问
        * `[]`键访问
        * 区别：
            - 键访问可以用字符串计算确定属性名`['l'+'zm']`,使用非字符串会转成字符串
            - 属性访问要求属性名满足标识符命名规范；键访问可以接受任意字符串
- 可计算属性名
    + ES6增加了可计算属性名`{[ pro + "bar"]: "hello"}`
    + ES6符号Symbol：一个不透明且无法预测的值`{[Symbol.sth] = "hello"]}`
- 属性与方法
    + 方法：对象的函数
    + 函数永远不会只成为一个对象的属性，函数和对象的关系最多也只是间接关系
    + 最保险的说法，函数和方法再JavaScript中可以互换
    + ES6新增super引用，class中有时候把super绑定的函数称为方法，语义上的差别。但本质上也是间接关系。因为函数不会属于对象，只是对于相同函数对象的多个引用
- 数组
    + 数组是一套更加结构化的值存储机制，不过不限制值的类型
    + 数组也是对象，可以给数组添加属性`array.pro = value //["pro":"value"]`但length不会加长。但是不建议使用数组当做键值对对象使用
    + 如果添加的属性名可以转成数字，那么会被当做下标`array["4"] = value //[empty,empty,empty,empty,value]`
- 复制对象
    + 浅复制
        * 新对象复制旧对象的值，新对象内部的属性和旧对象内部的属性的引用对象相同，即修改旧对象，新对象也会修改，因为引用的是同一个地址的对象
        * ES6 Object.assign()
    + 深复制
        * 新对象复制旧对象之外还复制旧对象的属性
        * 实现
            - 递归浅复制，把旧对象的属性遍历复制给新对象
            - 对于JSON安全的对象，即可以被序列化且可以解析的对象
                `var newObj = JSON.parse(JSON.stringify(obj))`
- 属性描述符
    + 
- 不变性
    + 对象常量
        * writable：false
        * configurable：false
    + 禁止扩展
        * Object.preventExtensions(Obj)禁止一个对象添加新属性并保留已有属性
        `Object.PreventExtensions(obj); obj.b = 3; obj.b//undefined`
    + 密封
        * Object.seal()创建一个密封的对象
        * 实现：在现有对象上调用preventExtensions()并把所有属性configurable:false
        * 密封之后不能修改添加新属性，也不能重新配置或delete任何属性，可以修改值
    + 冻结
        * Object.freeze()创建一个冻结对象
        * 实现：在现有对象上调用seal()并把所有属性标记为writable:false
        * 冻结之后，无法修改值
        * 冻结拥有最高级别的不变性
    + 上述所有方法创建的都是浅不变性，即只会影响目标对象和其直接属性，若目标对象引用其他对象，其他对象的内部不受影响，仍然可变。若需要深不变性，遍历引用的所有的对象并调用相应方法即可。很少需要深不变性
- `[[Get]]`
    + 对象的属性访问实际上是实现了[[Get]]操作
    + 如果当前对象和原型链都没有找到相同名称的属性，会返回undefined
- `[[Put]]`
    + 设置属性或创建属性
- Getter和Setter
    + 都是隐藏函数，分别在获取属性值时和设置属性值时调用
    + 当同时给属性定义getter和setter时，此属性会被定义为访问描述符，它们的value和writable特性会被忽略
    + 两种方法配置
        * 对象字面量中`get a(){}`
        * Object.defineProperty(obj,prop,{get:f,set:f})
```
var obj = {
    get a(){
        return 1
    }
}

Object.defineProperty(obj,'b',{
    get:function(){
        return 2
    }
    })
```

- 存在性
    + `prop in obj`检查属性是否在对象及其原型链中
        * `in`检查属性名是否存在而不是值，不能用来检查值在不在数组中
    + `obj.hasOwnProperty(prop)`检查属性是否在对象中
    + `Object.prototype.hasOwnProperty.call(obj,prop)`判断存在性的强硬方法
    + 可枚举
        * 可以出现在对象属性的遍历中`enumerable:true`
        * `for in`最好只应用在对象上
        * `obj.propertyIsEnumberable(prop)`检查给定的属性名是否直接存在于对象中并满足enumerable:true
        * `Object.keys(obj)`返回一个数组，包含所有可枚举属性
        * `Object.getOwnPropertyNames(obj)`返回一个数组，包含所有属性

<a id="遍历"></a>
### 遍历
- 遍历属性
    + 遍历对象
        * `for in`
    + 遍历数组
        * `for`遍历数组下标指向值
        * ES5数组的辅助迭代器 `forEach` `every` `some`
            - forEach忽略回调函数的返回值
            - every一直运行到回调函数返回值为false
            - some一直运行到回调函数返回值为true
            - every和some类似于for循环中的break
- 直接遍历值
    + ES6 `for of`
        * 被访问对象请求一个迭代器对象，通过调用迭代器对象的next方法遍历所有返回值
        * 数组有内置的@@iterator，对象需要定义迭代器
        * @@iterator本身不是一个迭代器对象，而是一个返回迭代器对象的函数，使用时需要函数执行`myArr[Symbol.iterator]()`
        * `next()`返回形式`{value:.., done:..}`done表示遍历是否结束
        * 每次调用迭代器对象的next()内部指针都会向前移动并返回对象属性列表的下一个值
    + 使用
```
for(var i of array){
    console.log(i)
}
//array[0]
//array[1]
...
//使用Symbol.iterator获取对象的@@iterator内部属性
var it = array[Symbol.iterator]();
it.next()//{value:array[0],done:false}
...
it.next()//{done:true}
```

<a id="混合对象“类”"></a>
## 混合对象“类”
<a id="类理论"></a>
### 类理论
- 类的设计模式
    + 类是一种设计模式，不是必须的编程基础
- JavaScript中的类
    + JavaScript中没有类，提供了一些近似类的语法
<a id="类的机制"></a>

<a id="类的机制"></a>
### 类的机制
- 建造
    + 类和实例的关系
- 构造函数
    + 构造类实例的一个特殊类方法

<a id="类的继承"></a>
### 类的继承
- 多态
    + 虚拟多态，相对多态
- 多重继承

<a id="混入"></a>
### 混入
- 显式混入
- 隐式混入

<a id="原型"></a>
## 原型


<a id="行为委托"></a>
## 行为委托
<a id="es6中的class"></a>
## ES6中的class
<a id="类型和语法"></a>
# 类型和语法
<a id="类型"></a>
## 类型
<a id="值"></a>
## 值
<a id="原生函数"></a>
## 原生函数
<a id="强制类型转换"></a>
## 强制类型转换
<a id="语法"></a>
## 语法
<a id="混合环境javascript"></a>
## 混合环境JavaScript
<a id="异步和性能"></a>
# 异步和性能
<a id="异步的现在和将来"></a>
## 异步的现在和将来
<a id="回调"></a>
## 回调
<a id="promise"></a>
## Promise
<a id="生成器"></a>
## 生成器
<a id="程序性能"></a>
## 程序性能
<a id="性能测试与调优"></a>
## 性能测试与调优
<a id="asynquence库"></a>
## asynquence库
<a id="高级异步模式"></a>
## 高级异步模式
<a id="起步上路"></a>
# 起步上路
<a id="深入编程"></a>
## 深入编程

<a id="深入javascript"></a>
## 深入JavaScript
<a id="es6及更新版本"></a>
# ES6及更新版本
<a id="es的现在与未来"></a>
## ES的现在与未来
<a id="es6语法"></a>
## ES6语法
<a id="代码组织"></a>
## 代码组织
<a id="异步流控制"></a>
## 异步流控制
<a id="集合"></a>
## 集合
<a id="新增api"></a>
## 新增API
<a id="元编程"></a>
## 元编程
<a id="es6之后"></a>
## ES6之后






