# 作用域和闭包
## 作用域是什么 
- 作用域是一套设计良好的规则。用来存储变量，并且之后可以方便的找到这些变量。

### 编译原理
- 传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤
    + 分词/词法分析(tokenizing/lexing)
        * 这个过程会将字符组成的代码分解成有意义的代码块(词法单元)
        * `var a = 1;`被分解成var、a、=、1、;。空格在关键的地方会被当做词法单元
    + 解析/语法分析(Parsing)
        * 这个过程将词法单元流(数组[var, a, =, 1, ;])转换成一个代表了程序语法结构的由元素逐级嵌套所组成的的树(抽象语法树,AST)。
        * `var a = 1;`转换成的抽象语法树有一个叫VariableDeclaration(变量声明)的顶级节点，接下来是一个值为a叫做Identifier(标识符)的子节点，以及一个值为=叫做AssignmentExpression(赋值表达式)的子节点。AssignmentExpression有一个值为1叫做NumericLiteral(数字文字)的子节点
    + 代码生成
        * 这个过程将AST转换为可执行代码。这个过程和语言、目标平台息息相关
        * 将`var a = 1;`的AST转化为一组机器指令，用来创建一个叫做a的变量(包括分配内存等)，并将一个值存储在a中
- JavaScript代码片段不是提前编译的，它 **就在** 执行前进行编译，编译发生在代码执行前几微秒甚至更短。编译结果不能在分布式系统中进行移植
    + JavaScript编译器会对`var a = 1;`进行编译，然后做好执行它的准备，并通常马上执行

### 理解作用域
- 引擎
    + 职责：从头到尾负责整个JavaScript程序的编译及执行过程
    + 术语：LHS和RHS
        + 在使用变量时，引擎会通过这两种查找来判断变量是否被声明
        + 分别表示赋值操作的左侧和右侧
        + LHS：目的是对变量进行赋值，对哪个变量赋值就对哪个变量进行LHS引用。对变量显式的赋值或者调用函数时传入实参就是LHS引用,如`a = 1`
        + RHS：目的是获取变量的值，获取哪个变量的值就是对哪个变量进行RHS引用。通过引用变量来获取值就是RHS引用，如`console.log(a)`
       
- 编译器
    + 职责：引擎的好朋友，负责词法分析、语法分析及代码生成等脏活累活
    + 变量的赋值操作：会执行两个动作
        + 首先编译器会在当前作用域中声明一个变量(如果之前没声明过)。这会在最开始的阶段，代码执行前进行。
        + 然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值
- 作用域
    + 职责：引擎的另一位好朋友，负责收集并维护所有变量(声明的标识符)组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

### 作用域嵌套
- 在当前作用域种无法找到某个变量，引擎就会在外层嵌套的作用域种继续查找，直到找到该变量为止。
- 作用域链

### 异常
- 为什么要区分LHS和RHS
    + 因为在变量没有被声明的情况下这两种查询的行为是不一样的
    + 用RHS引用查看变量是否被声明时，如果没声明(整条作用域链中)则抛出异常`ReferenceError`(引用异常，同作用域判别失败相关)
    + 用LHS引用查看变量是否被声明时，非严格模式下不会抛出异常，而且全局作用域中会创建该变量，并将其返还给引擎。严格模式下会抛出跟RHS一样的异常
    + 若RHS找到了变量，但尝试对这个变量做不合理的操作，如`null.getName()`会抛出异常`TypeError`(类型异常，作用域判别成功，对判别结果的操作异常)












