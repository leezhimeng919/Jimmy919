# 作用域和闭包
## 作用域是什么 
- 作用域是一套设计良好的规则。用来存储变量，并且之后可以方便的找到这些变量。

### 编译原理
- 传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤
    + 分词/词法分析(tokenizing/lexing)
        * 词法化(单词化)这个过程会将字符组成的代码分解成有意义的代码块(词法单元)
        * `var a = 1;`被分解成var、a、=、1、;。空格在关键的地方会被当做词法单元
        * 词法分析是*有状态*的解析规则进行的(即`ab`分成`a`和`b`还是`ab`要判断语境)
    + 解析/语法分析(Parsing)
        * 这个过程将词法单元流(数组)转换成一个代表了程序语法结构的由元素逐级嵌套所组成的的树(抽象语法树,AST)。
        * `var a = 1;`转换成的抽象语法树有一个叫VariableDeclaration(变量声明)的顶级节点，接下来是一个值为a叫做Identifier(标识符)的子节点，以及一个值为=叫做AssignmentExpression(赋值表达式)的子节点。AssignmentExpression有一个值为1叫做NumericLiteral(数字文字)的子节点
    + 代码生成
        * 这个过程将AST转换为可执行代码。这个过程和语言、目标平台息息相关
        * 将`var a = 1;`的AST转化为一组机器指令，用来创建一个叫做a的变量(包括分配内存等)，并将一个值存储在a中
- JavaScript代码片段不是提前编译的，它 **就在** 执行前进行编译，编译发生在代码执行前几微秒甚至更短。编译结果不能在分布式系统中进行移植
    + JavaScript编译器会对`var a = 1;`进行编译，然后做好执行它的准备，并通常马上执行

### 理解作用域
- 引擎
    + 职责：从头到尾负责整个JavaScript程序的编译及执行过程
    + 术语：LHS和RHS
        + 在使用变量时，引擎会通过这两种查找来判断变量是否被声明
        + 分别表示赋值操作的左侧和右侧
        + LHS：目的是对变量进行赋值，对哪个变量赋值就对哪个变量进行LHS引用。对变量显式的赋值或者调用函数时传入实参就是LHS引用,如a = 1
        + RHS：目的是获取变量的值，获取哪个变量的值就是对哪个变量进行RHS引用。通过引用变量来获取值就是RHS引用，如console.log(a)
       
- 编译器
    + 职责：引擎的好朋友，负责词法分析、语法分析及代码生成等脏活累活
    + 变量的赋值操作：会执行两个动作
        + 首先编译器会在当前作用域中声明一个变量(如果之前没声明过)。这会在最开始的阶段，代码执行前进行。
        + 然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值
- 作用域
    + 职责：引擎的另一位好朋友，负责收集并维护所有变量(声明的标识符)组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

### 作用域嵌套
- 在当前作用域种无法找到某个变量，引擎就会在外层嵌套的作用域种继续查找，直到找到该变量为止。
- 作用域链

### 异常
- 为什么要区分LHS和RHS
    + 因为在变量没有被声明的情况下这两种查询的行为是不一样的
    + 用RHS引用查看变量是否被声明时，如果没声明(整条作用域链中)则抛出异常ReferenceError(引用异常，同作用域判别失败相关)
    + 用LHS引用查看变量是否被声明时，非严格模式下不会抛出异常，而且全局作用域中会创建该变量，并将其返还给引擎。严格模式下会抛出跟RHS一样的异常
    + 若RHS找到了变量，但尝试对这个变量做不合理的操作，如null.getName()会抛出异常TypeError(类型异常，作用域判别成功，对判别结果的操作异常)

## 词法作用域
- 作用域共有两种主要的工作模型
    + 词法作用域
    + 动态作用域

### 词法阶段
- 词法作用域就是定义在词法阶段的作用域。
- 词法作用域是由你在写代码时将变量和块作用域写在哪来决定的，因此当词法分析器处理代码时会保持作用域不变(除非使用欺骗词法作用域的方法)
- 查找：作用域会在找到第一个匹配的标识符停止
- 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。

### 欺骗词法
- 欺骗词法作用域会导致性能下降
- `eval`和`with`能实现欺骗词法的目的
    + `eval()`接受一个字符串作为参数，并将其内容视为好像在书写代就存在于这个位置的代码。eval中的声明可以在运行期修改书写期的词法作用域
        + 严格模式下，eval中的声明无法修改所在的作用域
        + `setInterval`和`setTimeout`的第一个参数也可以是字符串类似于eval。不提倡
        + `new Function`的最后一个参数也可以接受字符串，避免使用
    - `with` 通常被当做重复引用同一个对象的多个属性的快捷方式，可以不需要重复引用对象本身
        + with可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域
        + 尽管with块可以将一个对象处理为词法作用域，但是这个块内部正常的var声明并不会被限制在这个块的作用域，而是被添加到with所处的作用域中
- eval函数如果接受了含有一个或多个声明的代码的字符串，就会[修改]其所处的词法作用域
- with声明实际上是根据你传递给它的对象凭空 [创建了一个全新] 的词法作用域
- 一个不推荐使用eval和with的原因是会被严格模式所影响

### 性能
- 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符

## 函数作用域和块作用域
### 函数中的作用域
- 属于这个函数的全部变量都可以在整个函数的范围内使用及复用

### 隐藏内部实现
- 规避冲突
    + 全局命名空间
    + 模块管理

### 函数作用域
- 匿名和具名
- 立即执行函数表达式

### 块作用域
- with
- try/catch
    + catch语句
- let
- const

## 提升
### 先有鸡(赋值)还是先有蛋(声明)
### 编译器如何处理
- 包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理

### 函数优先

## 作用域闭包
- 当函数可以记住并访问所在的词法作用域时，就产生的闭包，即使函数是在当前词法作用域之外执行

### 实质问题
- 闭包定义：当函数在其本身的词法作用域以外执行时，闭包就产生了
- 词法作用域的查找规则只是闭包的一部分，也是非常重要的一部分
- 个人理解：
    + 闭包是一个函数
    + 闭包一个作用域的容器
    + 闭包是一个引用，内部函数对外部作用域的引用
    + 闭包是的函数在别处被调用时可以继续访问定义时的词法作用域
- 内部函数具有一个涵盖包含函数作用域的闭包
- 无论通过何种手段将内部函数传递到所在的此法作用于以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包
- 自执行函数没用闭包，但同闭包息息相关
    + 息息相关：IIFE是最常用来创建被封闭起来的闭包的工具
    + 没用到闭包：函数并不是在其本身的词法作用域以外执行
- 只要用了回调函数就在使用闭包

### 循环和闭包







