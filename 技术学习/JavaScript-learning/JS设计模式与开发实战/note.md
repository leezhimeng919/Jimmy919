# 设计模式的适用性
- 软件开发的成本并非全部在开发阶段，设计模式的作用是让人们写出可复用和可维护性高的程序

- 接口的三种含义
    + 某一个库或者模块对外提供的接口
    + interface关键字
    + 面向接口编程的接口：是对象能响应的请求的集合


# 面向对象设计原则
- 单一职责原则 JS
    + Single Responsibility Principle
    + 定义：应该有且仅有一个引起类变化的原因
    + 在JS中：一个对象(方法)只做一件事情
    + 接口一定要做到单一职责
- 里氏替换原则 
    + Liskov Substitution Principle
    + 所有引用基类的地方必须能透明地使用其子类的对象
        * 只要父类能出现的地方子类就可以出现，替换为子类也不会产生错误和异常
    + 里氏替换原则为继承定义了一个良好的规范
        * 子类必须完全实现父类的方法
            - 如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生畸变，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承
        * 子类可以有自己的个性
            - 子类出现的地方父类未必就可以出现
        * 覆盖或实现父类的方法时参数可以被放大(前置条件相同或更宽松)
        * 覆盖或实现父类的方法时输出结果可以被缩小(后置条件范围相同或更小)
- 依赖倒置原则(6个设计原则中最难以实现的原则，实现开闭原则的重要途径)
    + 本质：通过抽象使个各类或模块的实现彼此独立，不相互影响，实现模块间的松耦合
    + 高层模块不应该依赖低层模块，两者都应该依赖其抽象
        * 底层模块是不可分割的原子逻辑
        * 高层模块是原子逻辑的再组装
        * 抽象就是指接口或抽象类，不能直接被实例化的
    + 抽象不应该依赖细节，细节应该依赖抽象
        * 抽象就是指 *接口或抽象类*，不能直接被实例化的
        * 细节就是 *实现类*，实现接口或继承抽象类而产生的类，特点是可以直接被实例化
    + 面向接口编程——OOD的精髓之一
        * 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的
        * 接口或抽象类不依赖与实现类
        * 实现类依赖接口或抽象类
    + 依赖的三种写法——只要做到依赖抽象，即使多层的依赖传递也不怕
        * 构造函数传递依赖对象
        * Setter方法传递依赖对象
        * 接口声明依赖对象
    + 最佳实践
        * 每个类尽量都有接口或实现类，或者抽象类和接口两者都具备
        * 变量的表面类型尽量是接口或者是抽象类
        * 任何类都不应该从具体类派生
        * 尽量不要覆盖基类的方法
        * 结合里氏替换原则使用
- 接口隔离原则
    + 建立单一接口，不要建立臃肿庞大的接口。一个模块一个接口
    + 接口分为两种
        * 实现接口
        * 类接口
    + 隔离两种定义
        * 客户端不应该依赖它不需要的接口
        * 类间的依赖关系应该建立在最小的接口上
    + 概括：接口中的方法尽量少，接口尽量细化
        * 与单一职责原则的区别
            - SRP注重职责，业务逻辑上的划分
            - 接口隔离原则注重接口方法尽量少
    + 接口隔离原则是对接口进行规范约束
        * **接口要尽量小**(核心)
            - 拆分接口的前提是不违背SRP
        * 接口要高内聚
            - 高内聚就是提高接口、类、模块的处理能力，减少对外的交互
            - 接口是对外的承诺，承诺越少对开发越有利，变更的风险越少，有利于成本降低
        * 定制服务
            - 模块之间必然会耦合，耦合就要有相互访问的接口，即需要为不同的访问者定制
            - 只提供访问者需要的方法
        * 接口设计是有限度的
            - 接口设计粒度越小，越灵活，但也更复杂
    + 最佳实践
        * 一个接口只服务于一个子模块或业务逻辑
        * 通过业务逻辑压缩接口中的public方法
        * 了解环境，拒绝盲从
        * 尽量修改已经被污染的接口
- 迪米特法则 (最少知识原则LKP) JS
    + 核心思想：类间解耦，弱耦合，提高类的复用率
    + 一个软件实体尽可能少地与其他实体发生相互作用
        * 软件实体：包括对象、系统、类、模块、函数、变量等
    + 减少对象之间的联系
        * 只跟朋友交流
        * 和朋友保持距离
        * 是自己就是自己的
            - 如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中
        * 谨慎使用serializable接口
- 开闭原则(最基础的一个原则，前五个都是开闭原则的具体形态，是指导设计的工具和方法，开闭原则是核心，是其他五个的抽象) JS
    + 软件实体是可扩展的(对扩展开放)，但是不可修改(对修改关闭)
    + 思想：当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，但是不允许改动程序源代码
        * 利用多态的思想,把不变的地方隔离开，封装变化的地方
        * 放置挂钩hook
        * 使用回调函数
    + 相对性
        * 挑选出最容易发生变化的地方，然后构造抽象来封闭这些变化
        * 在不可避免发生修改的时候，尽可能去修改相对容易修改的地方，比如修改开源库的配置文件
    + 如何使用
        * 抽象约束
        * 元数据控制模块行为
        * 指定项目章程
        * 封装变化
    + 最佳实践
        * solid
        * SRP-OCP-LSP-LOD-ISP-DIP
- 合成复用原则
    + composite Reuse principle
    + 尽量使用对象组合/聚合，而不是继承来达到复用的目的
    + 复用已有设计和实现两种方法
        * 组合/聚合关系
            - 优先考虑，黑箱复用
            - 两个类关系为Has-A：某一个角色具有某一项责任时使用
                + 鸟和翅膀是组合关系
                    * 整体与部分的关系，不可分，有相同的生命周期
                    * 组合是一种强聚合Contains-A
                + 鸟和鸟群是聚合关系
                    * 整体与个体的关系，可分，有各自的声明周期
                + 鸟和空气是依赖关系
                    * 依赖是类必须的需求
        * 继承
            - 称为白箱复用
            - 继承复用会破坏系统的封装性，继承会将基类的实现细节暴露给子类
            - 两个类关系为Is-A：一个类是另一个的一种时使用
                + 鸭和唐老鸭是继承关系
        * 补充：继承、实现、依赖、关联、聚合、组合
            - 依赖关系：具有偶然性、临时性
            - 关联关系：强依赖，具有长期性，平等性
            - 聚合关系：整体与个体的关系，可分，有各自的声明周期 has-a
            - 组合关系：整体与部分的关系，不可分，有相同的生命周期 contains-a
            - 关联和聚合：聚合的两个对象是不平等的，关联是一种结构化的关系
            - 强弱依次：组合>聚合>关联>依赖

 
# 24种设计模式(23个GoF设计模式 + 简单工厂模式)
- 创建型模式--封装创建对象的变化
    + 简单工厂模式
    + 单例模式 JS
        * 保证一个类仅有一个实例，并提供一个访问它的全局访问点
    + 工厂方法模式
    + 抽象工厂模式
    + 建造者模式
    + 原型模式 JS
        * 通过克隆一个对象来创建一个一模一样的对象，不再关心对象的具体类型
        * 实现关键在于语言本身是否提供clone方法，ES5提供了Object.create
        * 克隆是创建对象的手段:JS是一门基于原型的面向对象语言。
- 结构型模式--封装对象之间的组合关系
    + 代理模式 JS
    + 适配器模式 JS
    + 装饰模式 JS
    + 组合模式 JS
    + 门面(外观)模式
    + 享元模式 JS
    + 桥梁模式
- 行为型模式--封装对象的行为变化
    + 模板方法模式 JS
    + 中介者模式 JS
    + 命令模式 JS
    + 责任链模式 JS
    + 策略模式 JS
    + 迭代器模式 JS
    + 观察者模式 JS(发布-订阅模式)
    + 备忘录模式
    + 访问者模式
    + 状态模式 JS
    + 解析器模式


# 面向对象的JavaScript
- 鸭子类型思想：如果它走起来像鸭子，叫起来是鸭子，那么它就是鸭子
    + 面向接口编程，而不是面向实现编程
- 多态：同一个操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果
- 多态的作用：通过把过程化的条件分支语句转化为对象的多态性，从而1消除这些条件分支语句
- 封装：将信息隐藏，一般封装数据和封装实现，广义封装还包括封装类型和封装变化
    + 封装数据
        * java等语言提供private、public、protected等关键字来提供访问权限
        * JS依赖变量的作用于来实现封装,能模拟出private和public
        * 除了ES6提供的let外，一般用函数来创建作用域，symbol可以创建私有属性
    + 封装实现
        * 隐藏实现细节、设计细节以及隐藏对象的类型
        * 当修改对象时，可以随意地修改它的内部，只要对外的接口不变，就不会影响到程序的其他功能
    + 封装类型
        * 通过抽象类和接口来进行类型封装
        * 是静态类型语言的一种重要封装方式
    + 封装变化
        * 封装可能发生变化的地方
- 原型模式
    + 一种设计模式，也是一种编程泛型
    + JavaScript就是使用原型模式来搭建整个面向对象系统的
    + 原型编程泛型的一些规则
        * 所有的数据都是对象
            - JavaScript的根对象是Object.prototype
        * 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆他
            - JavaScript的函数既可以作为普通函数被调用，也可以作为构造器被调用
        * 对象会记住它的原型
        * 如果对象无法响应某个请求，它会把这个请求委托给它自己的原型
        
# this、call、apply
 - this
     + this总是指向一个对象，这个对象是在运行时基于函数的执行环境动态绑定的，而非函数声明时的环境
     + this的指向
         * 作为对象的方法调用
             - this指向该对象
         * 作为普通函数调用
             - this指向全局对象
         * 构造器调用
             - this指向返回对象
         * Function.prototype.call或Function.prototype.apply调用


# 闭包和高阶函数
